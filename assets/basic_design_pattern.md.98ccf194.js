import{o as e,c as a,a as h}from"./app.1b796cd1.js";const r='{"title":"设计模式","description":"","frontmatter":{},"headers":[{"level":2,"title":"面向对象","slug":"面向对象"},{"level":2,"title":"设计原则","slug":"设计原则"},{"level":2,"title":"工厂模式","slug":"工厂模式"},{"level":2,"title":"单例模式","slug":"单例模式"},{"level":2,"title":"适配器模式","slug":"适配器模式"},{"level":2,"title":"装饰器模式","slug":"装饰器模式"},{"level":2,"title":"代理模式","slug":"代理模式"},{"level":2,"title":"外观模式","slug":"外观模式"},{"level":2,"title":"观察者模式","slug":"观察者模式"},{"level":2,"title":"迭代器模式","slug":"迭代器模式"},{"level":2,"title":"状态模式","slug":"状态模式"},{"level":2,"title":"桥接模式","slug":"桥接模式"},{"level":2,"title":"亨元模式","slug":"亨元模式"},{"level":2,"title":"策略模式","slug":"策略模式"},{"level":2,"title":"模板方法","slug":"模板方法"},{"level":2,"title":"职责链模式","slug":"职责链模式"},{"level":2,"title":"备忘录模式","slug":"备忘录模式"},{"level":2,"title":"中介者模式","slug":"中介者模式"},{"level":2,"title":"访问者模式","slug":"访问者模式"},{"level":2,"title":"解释器模式","slug":"解释器模式"}],"relativePath":"basic/design_pattern.md","lastUpdated":1682066958436}',l={},t=h('<h1 id="设计模式"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h1><h2 id="面向对象"><a class="header-anchor" href="#面向对象" aria-hidden="true">#</a> 面向对象</h2><h2 id="设计原则"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h2><h2 id="工厂模式"><a class="header-anchor" href="#工厂模式" aria-hidden="true">#</a> 工厂模式</h2><blockquote><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p></blockquote><h2 id="单例模式"><a class="header-anchor" href="#单例模式" aria-hidden="true">#</a> 单例模式</h2><blockquote><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p></blockquote><h2 id="适配器模式"><a class="header-anchor" href="#适配器模式" aria-hidden="true">#</a> 适配器模式</h2><blockquote><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p></blockquote><h2 id="装饰器模式"><a class="header-anchor" href="#装饰器模式" aria-hidden="true">#</a> 装饰器模式</h2><blockquote><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p></blockquote><h2 id="代理模式"><a class="header-anchor" href="#代理模式" aria-hidden="true">#</a> 代理模式</h2><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p></blockquote><blockquote><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><h2 id="外观模式"><a class="header-anchor" href="#外观模式" aria-hidden="true">#</a> 外观模式</h2><h2 id="观察者模式"><a class="header-anchor" href="#观察者模式" aria-hidden="true">#</a> 观察者模式</h2><h2 id="迭代器模式"><a class="header-anchor" href="#迭代器模式" aria-hidden="true">#</a> 迭代器模式</h2><h2 id="状态模式"><a class="header-anchor" href="#状态模式" aria-hidden="true">#</a> 状态模式</h2><h2 id="桥接模式"><a class="header-anchor" href="#桥接模式" aria-hidden="true">#</a> 桥接模式</h2><h2 id="亨元模式"><a class="header-anchor" href="#亨元模式" aria-hidden="true">#</a> 亨元模式</h2><h2 id="策略模式"><a class="header-anchor" href="#策略模式" aria-hidden="true">#</a> 策略模式</h2><h2 id="模板方法"><a class="header-anchor" href="#模板方法" aria-hidden="true">#</a> 模板方法</h2><h2 id="职责链模式"><a class="header-anchor" href="#职责链模式" aria-hidden="true">#</a> 职责链模式</h2><h2 id="备忘录模式"><a class="header-anchor" href="#备忘录模式" aria-hidden="true">#</a> 备忘录模式</h2><h2 id="中介者模式"><a class="header-anchor" href="#中介者模式" aria-hidden="true">#</a> 中介者模式</h2><h2 id="访问者模式"><a class="header-anchor" href="#访问者模式" aria-hidden="true">#</a> 访问者模式</h2><h2 id="解释器模式"><a class="header-anchor" href="#解释器模式" aria-hidden="true">#</a> 解释器模式</h2>',27);l.render=function(h,r,l,d,i,s){return e(),a("div",null,[t])};export{r as __pageData,l as default};
